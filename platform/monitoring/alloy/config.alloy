// Grafana Alloy configuration for metrics collection
// Replaces deprecated Grafana Agent

// Remote write endpoint for sending metrics to Mimir
prometheus.remote_write "mimir" {
  endpoint {
    url = "http://mimir:8080/api/v1/push"
  }
}

// Scrape node-exporter for system metrics
prometheus.scrape "node_exporter" {
  targets = [
    {
      "__address__" = "node-exporter:9100",
      "job"        = "node-exporter",
    },
  ]

  forward_to = [prometheus.remote_write.mimir.receiver]
  scrape_interval = "15s"
  metrics_path = "/metrics"
}

// Scrape Mimir for self-monitoring
prometheus.scrape "mimir" {
  targets = [
    {
      "__address__" = "mimir:8080",
      "job"        = "mimir",
    },
  ]

  forward_to = [prometheus.remote_write.mimir.receiver]
  scrape_interval = "15s"
  metrics_path = "/metrics"
}

// Scrape Alloy for self-monitoring
prometheus.scrape "alloy" {
  targets = [
    {
      "__address__" = "localhost:12345",
      "job"        = "alloy",
    },
  ]

  forward_to = [prometheus.remote_write.mimir.receiver]
  scrape_interval = "15s"
  metrics_path = "/metrics"
}

// =====================================
// LOG COLLECTION PIPELINE
// =====================================

// Discover Docker containers to collect logs from
discovery.docker "docker_containers" {
  host = "unix:///var/run/docker.sock"
}

// Extract container metadata and add labels
discovery.relabel "docker_containers" {
  targets = discovery.docker.docker_containers.targets

  // Add container name as label
  rule {
    source_labels = ["__meta_docker_container_name"]
    target_label = "container"
    regex = "/(.*)"
    replacement = "$1"
  }

  // Add image name as label
  rule {
    source_labels = ["__meta_docker_container_image"]
    target_label = "image"
  }

  // Add compose service name if available
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label = "compose_service"
  }

  // Filter to only collect logs from specific containers
  // Include all containers but you can filter here if needed
  rule {
    source_labels = ["__meta_docker_container_name"]
    action = "keep"
    regex = ".*"
  }
}

// Collect logs from Docker containers
loki.source.docker "docker_logs" {
  host = "unix:///var/run/docker.sock"
  targets = discovery.relabel.docker_containers.output
  forward_to = [loki.process.process_logs.receiver]
  refresh_interval = "5s"
}

// Process logs before sending to Loki
loki.process "process_logs" {
  // Parse Docker logs format
  stage.docker {}

  // Parse JSON logs from structured logging
  stage.json {
    expressions = {
      level = "level",
      service = "service",
      version = "version",
      environment = "environment",
      request_id = "request_id",
      method = "method",
      path = "path",
      status = "status",
      duration_ms = "duration_ms",
    }
  }

  // Use timestamp from JSON if available, otherwise use Docker timestamp
  stage.timestamp {
    source = "timestamp"
    format = "RFC3339"
  }

  // Set labels from parsed JSON
  stage.labels {
    values = {
      level = "level",
      service = "service",
      method = "method",
      status = "status",
    }
  }

  // Add static labels
  stage.static_labels {
    values = {
      source = "docker",
    }
  }

  forward_to = [loki.write.local_loki.receiver]
}

// Send logs to Loki
loki.write "local_loki" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
  }
}

// Logging configuration
logging {
  level = "info"
}
