name: Build & Push Applications

on:
  push:
    branches: [master]
    paths:
      - 'applications/**'
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Specific app to build (leave empty for all changed apps)'
        required: false
        type: string

concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY_URL: registry.lvs.me.uk

jobs:
  detect-app-changes:
    name: 'Detect Changed Applications'
    runs-on: ubuntu-latest
    outputs:
      apps: ${{ steps.detect.outputs.apps }}
      has_changes: ${{ steps.detect.outputs.has_changes }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect changed applications
        id: detect
        run: |
          set -e

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ -n "${{ inputs.app_name }}" ]; then
              echo "apps=[\"${{ inputs.app_name }}\"]" >> $GITHUB_OUTPUT
              echo "has_changes=true" >> $GITHUB_OUTPUT
              echo "Manual build requested for: ${{ inputs.app_name }}"
              exit 0
            fi
          fi

          # Check if applications changed
          app_changes=$(git diff --name-only HEAD^ HEAD | grep "^applications/" || true)

          if [ -z "$app_changes" ]; then
            echo "No application changes detected"
            echo "apps=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get changed apps
          changed_apps=$(echo "$app_changes" | cut -d'/' -f2 | sort -u)
          if [ -z "$changed_apps" ]; then
            apps="[]"
            has_changes="false"
          else
            apps=$(echo "$changed_apps" | tr ' ' '\n' | grep -v '^$' | jq -R . | jq -s -c .)
            has_changes="true"
          fi
          echo "Changed applications: $apps"

          echo "apps=$apps" >> $GITHUB_OUTPUT
          echo "has_changes=$has_changes" >> $GITHUB_OUTPUT

          # Verify apps have required files
          if [ "$has_changes" = "true" ]; then
            echo "$apps" | jq -r '.[]' | while read app; do
              if [ ! -f "applications/$app/Dockerfile" ]; then
                echo "‚ö†Ô∏è  Warning: applications/$app/Dockerfile not found"
              fi
            done
          fi

  build-applications:
    name: 'Build & Push Applications'
    runs-on: ubuntu-latest
    needs: [detect-app-changes]
    if: |
      always() && !cancelled() && !failure() &&
      needs.detect-app-changes.outputs.has_changes == 'true'
    strategy:
      matrix:
        app: ${{ fromJSON(needs.detect-app-changes.outputs.apps) }}
      fail-fast: false

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Verify app structure
        run: |
          set -e
          if [ ! -f "applications/${{ matrix.app }}/Dockerfile" ]; then
            echo "‚ùå Error: applications/${{ matrix.app }}/Dockerfile not found"
            exit 1
          fi
          echo "‚úÖ App structure verified for ${{ matrix.app }}"

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_URL }}/${{ matrix.app }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./applications/${{ matrix.app }}
          platforms: linux/amd64
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.app }}
          cache-to: type=gha,mode=max,scope=${{ matrix.app }}
          outputs: type=docker,dest=/tmp/${{ matrix.app }}.tar

      - name: Login and push with retry
        run: |
          set -e

          # Function to attempt registry login and push
          push_with_retry() {
            local attempt=1
            local max_attempts=5
            local delay=10

            while [ $attempt -le $max_attempts ]; do
              echo "üîÑ Attempt $attempt/$max_attempts: Logging in and pushing to registry..."

              # Try to login and push
              if echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY_URL }} -u "${{ secrets.REGISTRY_USERNAME }}" --password-stdin; then
                echo "‚úÖ Successfully logged in to registry"

                # Load the image
                docker load --input /tmp/${{ matrix.app }}.tar

                # Push all tags
                echo "${{ steps.meta.outputs.tags }}" | while read -r tag; do
                  if [ -n "$tag" ]; then
                    echo "üì¶ Pushing $tag..."
                    if docker push "$tag"; then
                      echo "‚úÖ Successfully pushed $tag"
                    else
                      echo "‚ùå Failed to push $tag on attempt $attempt"
                      return 1
                    fi
                  fi
                done

                echo "üéâ All images pushed successfully for ${{ matrix.app }}"
                return 0
              else
                echo "‚ùå Registry login failed on attempt $attempt"
              fi

              if [ $attempt -lt $max_attempts ]; then
                echo "‚è≥ Waiting ${delay}s before retry..."
                sleep $delay
                delay=$((delay * 2))  # Exponential backoff
              fi

              attempt=$((attempt + 1))
            done

            echo "üí• Failed to push after $max_attempts attempts"
            return 1
          }

          # Execute push with retry
          push_with_retry

      - name: Cleanup
        if: always()
        run: |
          rm -f /tmp/${{ matrix.app }}.tar
          docker logout ${{ env.REGISTRY_URL }} || true
